---
title: SDLC--Waterfall Model
author: Max
date: 08.19.2018
layout: post
---
Customer’s requirements to the delivered product as well as customer’s budgets. We need to choice among different types of models: waterfall model, spiral model, kanban development model, rapid prototyping, scrum model, etc. Selection of a particular type of life-cycle model depends largely on the project scope and stakes.

Waterfall Model is for small and trivial projects. According to the Waterfall model, development proceeds from one phase to another. What’s important, you can’t move forward until the previous stage has been completed. The project is implemented step-by-step in accordance with the precise sequence: requirements gathering and study, software design, software development, software testing and software maintenance.
 
 <a href="#" class="image fit"><img src="{{ 'assets/images/Waterfall_model.svg' | relative_url }}" alt="Ipsum Feugiat" /></a>
 
1. Requirements Analysis (Requirements Phase) 
At this phase, it is important to document all requirements to the desired software. You should dedicate sufficient time to this phase, conducting extensive interviews with stakeholders. It is better to structure all incoming data, analyze them, consider all technical limitations that may arise on the client’s side, and come out with a ready-to-follow specification to meet the client’s needs. Another thing to consider is any constraints that may hinder the development process, such as client’s time and budget constraints.

*Notice: Create a detailed problem vision document, specifying the problem background, business goals and success criteria for the project, factors of business risk and description of the product end-user group. Additional requirements that arise on the development phase.


2. Software Design Phase 
Creation of a project scope document with mockups, or hand-drawn sketches, and a detailed software development specification. The project scope document should include project description with main functions defined with regard to the problem vision document, and, of course, timeline and bugets.


3. Software Development Life Cycle Phase 
Creation of an interactive prototype that is actually the skeleton of the future application. This step involves little coding, like coding buttons and simple forms. As soon as you are ready with the interactive prototype and application design and they are confirmed by the client, proceed with working out the application standards (naming conventions, how the code will be documented, a formation of end-user instructions, etc.). Afterward, you can get down to the next step in the life cycle, namely software development. It can be subdivided into small units, and each unit is developed and tested by developers for its functionality (unit testing).


4. Software Testing Phase 
Once the product is developed, it should undergo a meticulous quality assurance and software testing to make sure that it solves the needs set forth during the requirements study phase.


5. Software Maintenance Phase 
Generally, it includes some minor bug fixes that are usually made during this phase. However, you still may have to make some changes in the produced software, disregarding your efforts on the earlier phases. The client may come up with functionality enhancements to the developed software and you will have to collect, describe and discuss the new requirements with the client to have these modifications made. In this case, you come up with a new waterfall project and have to repeat all the above-described steps.


Waterfall Pros: 
1 Simple to use and easy to understand 
2 Easy to manage and maintain thanks to rigid and precise phases 
3 All stages are well documented 
4 High visibility on the current progress 
5 Low chance of unexpected financial expenses 
6 Easy testing 
7 The outcome is clear 
8 Lack of flexibility

Waterfall Cons: 
1 Increased delivery time 
2 A small change in one phase causes many changes in all subsequent 
3 Software deliverables are available only at the end of a cycle

Where to use: 
This model is canonical for military, space, medical and life-critical systems such as flight control software, airbag systems, etc. It can be also used for small and trivial projects.
